package com.leveldown.entity;import com.leveldown.main.Game;import com.leveldown.main.Sound;import com.leveldown.world.Camera;import com.leveldown.world.World;import java.awt.Graphics;import java.awt.Rectangle;import java.awt.image.BufferedImage;import java.awt.image.ImageObserver;public class Enemy extends Entity {   private double speed = 1.0D;   private int frames = 0;   private int maxFrames = 10;   private int index = 0;   private int maxIndex = 1;   private int maskx = 8;   private int masky = 8;   private int maskw = 10;   private int maskh = 10;   private BufferedImage[] sprites = new BufferedImage[2];   private int life = 5;   private boolean isDameged = false;   private int damegeFrames = 8;   private int damegeCurrent = 0;   public Enemy(int x, int y, int width, int heigth, BufferedImage sprite) {      super(x, y, width, heigth, (BufferedImage)null);      this.sprites[0] = Game.spritesheet.getSprite(112, 16, 16, 16);      this.sprites[1] = Game.spritesheet.getSprite(128, 16, 16, 16);   }   public void tick() {      if (!this.isColindingWithPlayer()) {         if (Game.rand.nextInt(100) < 25) {            if ((int)this.x < Game.player.getX() && World.isFree((int)(this.x + this.speed), this.getY()) && !this.isColinding((int)(this.x + this.speed), this.getY())) {               this.x += this.speed;            } else if ((int)this.x > Game.player.getX() && World.isFree((int)(this.x - this.speed), this.getY()) && !this.isColinding((int)(this.x - this.speed), this.getY())) {               this.x -= this.speed;            }            if ((int)this.y < Game.player.getY() && World.isFree(this.getX(), (int)(this.y + this.speed)) && !this.isColinding(this.getX(), (int)(this.y + this.speed))) {               this.y += this.speed;            } else if ((int)this.y > Game.player.getY() && World.isFree(this.getX(), (int)(this.y - this.speed)) && !this.isColinding(this.getX(), (int)(this.y - this.speed))) {               this.y -= this.speed;            }         }      } else {         if (Game.rand.nextInt(100) < 10) {            Sound.hurtEffect.play();            Player var10000 = Game.player;            var10000.life -= (double)Game.rand.nextInt(5);            Game.player.isDamaged = true;         }      }      ++this.frames;      if (this.frames == this.maxFrames) {         this.frames = 0;         ++this.index;         if (this.index > this.maxIndex) {            this.index = 0;         }      }      this.ColindingWithBullet();      if (this.life <= 0) {         this.destroySelf();      } else {         if (this.isDameged) {            ++this.damegeCurrent;            if (this.damegeCurrent == this.damegeFrames) {               this.damegeCurrent = 0;               this.isDameged = false;            }         }      }   }   public void destroySelf() {      Game.enemies.remove(this);      Game.entities.remove(this);   }   public void ColindingWithBullet() {      for(int i = 0; i < Game.bullets.size(); ++i) {         Entity e = (Entity)Game.bullets.get(i);         if (e instanceof BulletShoot && Bullet.isColidding(this, e)) {            Sound.hurtEffect.play();            this.isDameged = true;            --this.life;            Game.bullets.remove(i);            return;         }      }   }   public boolean isColindingWithPlayer() {      Rectangle enemyCurrent = new Rectangle(this.getX() + this.maskx, this.getY() + this.masky, this.maskw, this.maskh);      Rectangle player = new Rectangle(Game.player.getX(), Game.player.getY(), 16, 16);      return enemyCurrent.intersects(player);   }   public boolean isColinding(int xnext, int ynext) {      Rectangle enemyCurrent = new Rectangle(xnext + this.maskx, ynext + this.masky, this.maskw, this.maskh);      for(int i = 0; i < Game.enemies.size(); ++i) {         Enemy e = (Enemy)Game.enemies.get(i);         if (e != this) {            Rectangle targetEnemy = new Rectangle(e.getX() + this.maskx, e.getY() + this.masky, this.maskw, this.maskh);            if (enemyCurrent.intersects(targetEnemy)) {               return true;            }         }      }      return false;   }   public void render(Graphics g) {      if (!this.isDameged) {         g.drawImage(this.sprites[this.index], this.getX() - Camera.x, this.getY() - Camera.y, (ImageObserver)null);      } else {         g.drawImage(Entity.ENEMY_EN2, this.getX() - Camera.x, this.getY() - Camera.y, (ImageObserver)null);      }   }}